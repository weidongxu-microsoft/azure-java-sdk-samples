// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.management.vanilla.network.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.HttpPipeline;
import com.azure.core.http.HttpPipelineBuilder;
import com.azure.core.http.policy.CookiePolicy;
import com.azure.core.http.policy.RetryPolicy;
import com.azure.core.http.policy.UserAgentPolicy;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.management.AzureEnvironment;
import com.azure.core.management.exception.ManagementException;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.core.util.polling.AsyncPollResponse;
import com.azure.core.util.polling.PollerFlux;
import com.azure.management.AzureServiceClient;
import com.azure.management.vanilla.network.models.BastionActiveSessionListResult;
import com.azure.management.vanilla.network.models.BastionSessionDeleteResult;
import com.azure.management.vanilla.network.models.BastionSessionState;
import com.azure.management.vanilla.network.models.BastionShareableLink;
import com.azure.management.vanilla.network.models.BastionShareableLinkListRequest;
import com.azure.management.vanilla.network.models.BastionShareableLinkListResult;
import com.azure.management.vanilla.network.models.DnsNameAvailabilityResult;
import com.azure.management.vanilla.network.models.SessionIds;
import com.azure.management.vanilla.network.models.VirtualWanSecurityProviders;
import com.azure.management.vanilla.network.models.VirtualWanVpnProfileParameters;
import com.azure.management.vanilla.network.models.VpnProfileResponse;
import java.nio.ByteBuffer;
import java.util.List;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/** Initializes a new instance of the NetworkManagementClientImpl type. */
public final class NetworkManagementClientImpl extends AzureServiceClient {
    private final ClientLogger logger = new ClientLogger(NetworkManagementClientImpl.class);

    /** The proxy service used to perform REST calls. */
    private final NetworkManagementClientService service;

    /**
     * The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms
     * part of the URI for every service call.
     */
    private String subscriptionId;

    /**
     * Gets The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID
     * forms part of the URI for every service call.
     *
     * @return the subscriptionId value.
     */
    public String getSubscriptionId() {
        return this.subscriptionId;
    }

    /**
     * Sets The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID
     * forms part of the URI for every service call.
     *
     * @param subscriptionId the subscriptionId value.
     * @return the service client itself.
     */
    public NetworkManagementClientImpl setSubscriptionId(String subscriptionId) {
        this.subscriptionId = subscriptionId;
        return this;
    }

    /** server parameter. */
    private String host;

    /**
     * Gets server parameter.
     *
     * @return the host value.
     */
    public String getHost() {
        return this.host;
    }

    /**
     * Sets server parameter.
     *
     * @param host the host value.
     * @return the service client itself.
     */
    public NetworkManagementClientImpl setHost(String host) {
        this.host = host;
        return this;
    }

    /** The HTTP pipeline to send requests through. */
    private final HttpPipeline httpPipeline;

    /**
     * Gets The HTTP pipeline to send requests through.
     *
     * @return the httpPipeline value.
     */
    public HttpPipeline getHttpPipeline() {
        return this.httpPipeline;
    }

    /** The ApplicationGatewaysImpl object to access its operations. */
    private final ApplicationGatewaysImpl applicationGateways;

    /**
     * Gets the ApplicationGatewaysImpl object to access its operations.
     *
     * @return the ApplicationGatewaysImpl object.
     */
    public ApplicationGatewaysImpl getApplicationGateways() {
        return this.applicationGateways;
    }

    /** The ApplicationSecurityGroupsImpl object to access its operations. */
    private final ApplicationSecurityGroupsImpl applicationSecurityGroups;

    /**
     * Gets the ApplicationSecurityGroupsImpl object to access its operations.
     *
     * @return the ApplicationSecurityGroupsImpl object.
     */
    public ApplicationSecurityGroupsImpl getApplicationSecurityGroups() {
        return this.applicationSecurityGroups;
    }

    /** The AvailableDelegationsImpl object to access its operations. */
    private final AvailableDelegationsImpl availableDelegations;

    /**
     * Gets the AvailableDelegationsImpl object to access its operations.
     *
     * @return the AvailableDelegationsImpl object.
     */
    public AvailableDelegationsImpl getAvailableDelegations() {
        return this.availableDelegations;
    }

    /** The AvailableResourceGroupDelegationsImpl object to access its operations. */
    private final AvailableResourceGroupDelegationsImpl availableResourceGroupDelegations;

    /**
     * Gets the AvailableResourceGroupDelegationsImpl object to access its operations.
     *
     * @return the AvailableResourceGroupDelegationsImpl object.
     */
    public AvailableResourceGroupDelegationsImpl getAvailableResourceGroupDelegations() {
        return this.availableResourceGroupDelegations;
    }

    /** The AvailableServiceAliasesImpl object to access its operations. */
    private final AvailableServiceAliasesImpl availableServiceAliases;

    /**
     * Gets the AvailableServiceAliasesImpl object to access its operations.
     *
     * @return the AvailableServiceAliasesImpl object.
     */
    public AvailableServiceAliasesImpl getAvailableServiceAliases() {
        return this.availableServiceAliases;
    }

    /** The AzureFirewallsImpl object to access its operations. */
    private final AzureFirewallsImpl azureFirewalls;

    /**
     * Gets the AzureFirewallsImpl object to access its operations.
     *
     * @return the AzureFirewallsImpl object.
     */
    public AzureFirewallsImpl getAzureFirewalls() {
        return this.azureFirewalls;
    }

    /** The AzureFirewallFqdnTagsImpl object to access its operations. */
    private final AzureFirewallFqdnTagsImpl azureFirewallFqdnTags;

    /**
     * Gets the AzureFirewallFqdnTagsImpl object to access its operations.
     *
     * @return the AzureFirewallFqdnTagsImpl object.
     */
    public AzureFirewallFqdnTagsImpl getAzureFirewallFqdnTags() {
        return this.azureFirewallFqdnTags;
    }

    /** The BastionHostsImpl object to access its operations. */
    private final BastionHostsImpl bastionHosts;

    /**
     * Gets the BastionHostsImpl object to access its operations.
     *
     * @return the BastionHostsImpl object.
     */
    public BastionHostsImpl getBastionHosts() {
        return this.bastionHosts;
    }

    /** The DdosCustomPoliciesImpl object to access its operations. */
    private final DdosCustomPoliciesImpl ddosCustomPolicies;

    /**
     * Gets the DdosCustomPoliciesImpl object to access its operations.
     *
     * @return the DdosCustomPoliciesImpl object.
     */
    public DdosCustomPoliciesImpl getDdosCustomPolicies() {
        return this.ddosCustomPolicies;
    }

    /** The DdosProtectionPlansImpl object to access its operations. */
    private final DdosProtectionPlansImpl ddosProtectionPlans;

    /**
     * Gets the DdosProtectionPlansImpl object to access its operations.
     *
     * @return the DdosProtectionPlansImpl object.
     */
    public DdosProtectionPlansImpl getDdosProtectionPlans() {
        return this.ddosProtectionPlans;
    }

    /** The AvailableEndpointServicesImpl object to access its operations. */
    private final AvailableEndpointServicesImpl availableEndpointServices;

    /**
     * Gets the AvailableEndpointServicesImpl object to access its operations.
     *
     * @return the AvailableEndpointServicesImpl object.
     */
    public AvailableEndpointServicesImpl getAvailableEndpointServices() {
        return this.availableEndpointServices;
    }

    /** The ExpressRouteCircuitAuthorizationsImpl object to access its operations. */
    private final ExpressRouteCircuitAuthorizationsImpl expressRouteCircuitAuthorizations;

    /**
     * Gets the ExpressRouteCircuitAuthorizationsImpl object to access its operations.
     *
     * @return the ExpressRouteCircuitAuthorizationsImpl object.
     */
    public ExpressRouteCircuitAuthorizationsImpl getExpressRouteCircuitAuthorizations() {
        return this.expressRouteCircuitAuthorizations;
    }

    /** The ExpressRouteCircuitPeeringsImpl object to access its operations. */
    private final ExpressRouteCircuitPeeringsImpl expressRouteCircuitPeerings;

    /**
     * Gets the ExpressRouteCircuitPeeringsImpl object to access its operations.
     *
     * @return the ExpressRouteCircuitPeeringsImpl object.
     */
    public ExpressRouteCircuitPeeringsImpl getExpressRouteCircuitPeerings() {
        return this.expressRouteCircuitPeerings;
    }

    /** The ExpressRouteCircuitConnectionsImpl object to access its operations. */
    private final ExpressRouteCircuitConnectionsImpl expressRouteCircuitConnections;

    /**
     * Gets the ExpressRouteCircuitConnectionsImpl object to access its operations.
     *
     * @return the ExpressRouteCircuitConnectionsImpl object.
     */
    public ExpressRouteCircuitConnectionsImpl getExpressRouteCircuitConnections() {
        return this.expressRouteCircuitConnections;
    }

    /** The PeerExpressRouteCircuitConnectionsImpl object to access its operations. */
    private final PeerExpressRouteCircuitConnectionsImpl peerExpressRouteCircuitConnections;

    /**
     * Gets the PeerExpressRouteCircuitConnectionsImpl object to access its operations.
     *
     * @return the PeerExpressRouteCircuitConnectionsImpl object.
     */
    public PeerExpressRouteCircuitConnectionsImpl getPeerExpressRouteCircuitConnections() {
        return this.peerExpressRouteCircuitConnections;
    }

    /** The ExpressRouteCircuitsImpl object to access its operations. */
    private final ExpressRouteCircuitsImpl expressRouteCircuits;

    /**
     * Gets the ExpressRouteCircuitsImpl object to access its operations.
     *
     * @return the ExpressRouteCircuitsImpl object.
     */
    public ExpressRouteCircuitsImpl getExpressRouteCircuits() {
        return this.expressRouteCircuits;
    }

    /** The ExpressRouteServiceProvidersImpl object to access its operations. */
    private final ExpressRouteServiceProvidersImpl expressRouteServiceProviders;

    /**
     * Gets the ExpressRouteServiceProvidersImpl object to access its operations.
     *
     * @return the ExpressRouteServiceProvidersImpl object.
     */
    public ExpressRouteServiceProvidersImpl getExpressRouteServiceProviders() {
        return this.expressRouteServiceProviders;
    }

    /** The ExpressRouteCrossConnectionsImpl object to access its operations. */
    private final ExpressRouteCrossConnectionsImpl expressRouteCrossConnections;

    /**
     * Gets the ExpressRouteCrossConnectionsImpl object to access its operations.
     *
     * @return the ExpressRouteCrossConnectionsImpl object.
     */
    public ExpressRouteCrossConnectionsImpl getExpressRouteCrossConnections() {
        return this.expressRouteCrossConnections;
    }

    /** The ExpressRouteCrossConnectionPeeringsImpl object to access its operations. */
    private final ExpressRouteCrossConnectionPeeringsImpl expressRouteCrossConnectionPeerings;

    /**
     * Gets the ExpressRouteCrossConnectionPeeringsImpl object to access its operations.
     *
     * @return the ExpressRouteCrossConnectionPeeringsImpl object.
     */
    public ExpressRouteCrossConnectionPeeringsImpl getExpressRouteCrossConnectionPeerings() {
        return this.expressRouteCrossConnectionPeerings;
    }

    /** The ExpressRoutePortsLocationsImpl object to access its operations. */
    private final ExpressRoutePortsLocationsImpl expressRoutePortsLocations;

    /**
     * Gets the ExpressRoutePortsLocationsImpl object to access its operations.
     *
     * @return the ExpressRoutePortsLocationsImpl object.
     */
    public ExpressRoutePortsLocationsImpl getExpressRoutePortsLocations() {
        return this.expressRoutePortsLocations;
    }

    /** The ExpressRoutePortsImpl object to access its operations. */
    private final ExpressRoutePortsImpl expressRoutePorts;

    /**
     * Gets the ExpressRoutePortsImpl object to access its operations.
     *
     * @return the ExpressRoutePortsImpl object.
     */
    public ExpressRoutePortsImpl getExpressRoutePorts() {
        return this.expressRoutePorts;
    }

    /** The ExpressRouteLinksImpl object to access its operations. */
    private final ExpressRouteLinksImpl expressRouteLinks;

    /**
     * Gets the ExpressRouteLinksImpl object to access its operations.
     *
     * @return the ExpressRouteLinksImpl object.
     */
    public ExpressRouteLinksImpl getExpressRouteLinks() {
        return this.expressRouteLinks;
    }

    /** The FirewallPoliciesImpl object to access its operations. */
    private final FirewallPoliciesImpl firewallPolicies;

    /**
     * Gets the FirewallPoliciesImpl object to access its operations.
     *
     * @return the FirewallPoliciesImpl object.
     */
    public FirewallPoliciesImpl getFirewallPolicies() {
        return this.firewallPolicies;
    }

    /** The FirewallPolicyRuleGroupsImpl object to access its operations. */
    private final FirewallPolicyRuleGroupsImpl firewallPolicyRuleGroups;

    /**
     * Gets the FirewallPolicyRuleGroupsImpl object to access its operations.
     *
     * @return the FirewallPolicyRuleGroupsImpl object.
     */
    public FirewallPolicyRuleGroupsImpl getFirewallPolicyRuleGroups() {
        return this.firewallPolicyRuleGroups;
    }

    /** The IpAllocationsImpl object to access its operations. */
    private final IpAllocationsImpl ipAllocations;

    /**
     * Gets the IpAllocationsImpl object to access its operations.
     *
     * @return the IpAllocationsImpl object.
     */
    public IpAllocationsImpl getIpAllocations() {
        return this.ipAllocations;
    }

    /** The IpGroupsImpl object to access its operations. */
    private final IpGroupsImpl ipGroups;

    /**
     * Gets the IpGroupsImpl object to access its operations.
     *
     * @return the IpGroupsImpl object.
     */
    public IpGroupsImpl getIpGroups() {
        return this.ipGroups;
    }

    /** The LoadBalancersImpl object to access its operations. */
    private final LoadBalancersImpl loadBalancers;

    /**
     * Gets the LoadBalancersImpl object to access its operations.
     *
     * @return the LoadBalancersImpl object.
     */
    public LoadBalancersImpl getLoadBalancers() {
        return this.loadBalancers;
    }

    /** The LoadBalancerBackendAddressPoolsImpl object to access its operations. */
    private final LoadBalancerBackendAddressPoolsImpl loadBalancerBackendAddressPools;

    /**
     * Gets the LoadBalancerBackendAddressPoolsImpl object to access its operations.
     *
     * @return the LoadBalancerBackendAddressPoolsImpl object.
     */
    public LoadBalancerBackendAddressPoolsImpl getLoadBalancerBackendAddressPools() {
        return this.loadBalancerBackendAddressPools;
    }

    /** The LoadBalancerFrontendIpConfigurationsImpl object to access its operations. */
    private final LoadBalancerFrontendIpConfigurationsImpl loadBalancerFrontendIpConfigurations;

    /**
     * Gets the LoadBalancerFrontendIpConfigurationsImpl object to access its operations.
     *
     * @return the LoadBalancerFrontendIpConfigurationsImpl object.
     */
    public LoadBalancerFrontendIpConfigurationsImpl getLoadBalancerFrontendIpConfigurations() {
        return this.loadBalancerFrontendIpConfigurations;
    }

    /** The InboundNatRulesImpl object to access its operations. */
    private final InboundNatRulesImpl inboundNatRules;

    /**
     * Gets the InboundNatRulesImpl object to access its operations.
     *
     * @return the InboundNatRulesImpl object.
     */
    public InboundNatRulesImpl getInboundNatRules() {
        return this.inboundNatRules;
    }

    /** The LoadBalancerLoadBalancingRulesImpl object to access its operations. */
    private final LoadBalancerLoadBalancingRulesImpl loadBalancerLoadBalancingRules;

    /**
     * Gets the LoadBalancerLoadBalancingRulesImpl object to access its operations.
     *
     * @return the LoadBalancerLoadBalancingRulesImpl object.
     */
    public LoadBalancerLoadBalancingRulesImpl getLoadBalancerLoadBalancingRules() {
        return this.loadBalancerLoadBalancingRules;
    }

    /** The LoadBalancerOutboundRulesImpl object to access its operations. */
    private final LoadBalancerOutboundRulesImpl loadBalancerOutboundRules;

    /**
     * Gets the LoadBalancerOutboundRulesImpl object to access its operations.
     *
     * @return the LoadBalancerOutboundRulesImpl object.
     */
    public LoadBalancerOutboundRulesImpl getLoadBalancerOutboundRules() {
        return this.loadBalancerOutboundRules;
    }

    /** The LoadBalancerNetworkInterfacesImpl object to access its operations. */
    private final LoadBalancerNetworkInterfacesImpl loadBalancerNetworkInterfaces;

    /**
     * Gets the LoadBalancerNetworkInterfacesImpl object to access its operations.
     *
     * @return the LoadBalancerNetworkInterfacesImpl object.
     */
    public LoadBalancerNetworkInterfacesImpl getLoadBalancerNetworkInterfaces() {
        return this.loadBalancerNetworkInterfaces;
    }

    /** The LoadBalancerProbesImpl object to access its operations. */
    private final LoadBalancerProbesImpl loadBalancerProbes;

    /**
     * Gets the LoadBalancerProbesImpl object to access its operations.
     *
     * @return the LoadBalancerProbesImpl object.
     */
    public LoadBalancerProbesImpl getLoadBalancerProbes() {
        return this.loadBalancerProbes;
    }

    /** The NatGatewaysImpl object to access its operations. */
    private final NatGatewaysImpl natGateways;

    /**
     * Gets the NatGatewaysImpl object to access its operations.
     *
     * @return the NatGatewaysImpl object.
     */
    public NatGatewaysImpl getNatGateways() {
        return this.natGateways;
    }

    /** The NetworkInterfacesImpl object to access its operations. */
    private final NetworkInterfacesImpl networkInterfaces;

    /**
     * Gets the NetworkInterfacesImpl object to access its operations.
     *
     * @return the NetworkInterfacesImpl object.
     */
    public NetworkInterfacesImpl getNetworkInterfaces() {
        return this.networkInterfaces;
    }

    /** The NetworkInterfaceIpConfigurationsImpl object to access its operations. */
    private final NetworkInterfaceIpConfigurationsImpl networkInterfaceIpConfigurations;

    /**
     * Gets the NetworkInterfaceIpConfigurationsImpl object to access its operations.
     *
     * @return the NetworkInterfaceIpConfigurationsImpl object.
     */
    public NetworkInterfaceIpConfigurationsImpl getNetworkInterfaceIpConfigurations() {
        return this.networkInterfaceIpConfigurations;
    }

    /** The NetworkInterfaceLoadBalancersImpl object to access its operations. */
    private final NetworkInterfaceLoadBalancersImpl networkInterfaceLoadBalancers;

    /**
     * Gets the NetworkInterfaceLoadBalancersImpl object to access its operations.
     *
     * @return the NetworkInterfaceLoadBalancersImpl object.
     */
    public NetworkInterfaceLoadBalancersImpl getNetworkInterfaceLoadBalancers() {
        return this.networkInterfaceLoadBalancers;
    }

    /** The NetworkInterfaceTapConfigurationsImpl object to access its operations. */
    private final NetworkInterfaceTapConfigurationsImpl networkInterfaceTapConfigurations;

    /**
     * Gets the NetworkInterfaceTapConfigurationsImpl object to access its operations.
     *
     * @return the NetworkInterfaceTapConfigurationsImpl object.
     */
    public NetworkInterfaceTapConfigurationsImpl getNetworkInterfaceTapConfigurations() {
        return this.networkInterfaceTapConfigurations;
    }

    /** The NetworkProfilesImpl object to access its operations. */
    private final NetworkProfilesImpl networkProfiles;

    /**
     * Gets the NetworkProfilesImpl object to access its operations.
     *
     * @return the NetworkProfilesImpl object.
     */
    public NetworkProfilesImpl getNetworkProfiles() {
        return this.networkProfiles;
    }

    /** The NetworkSecurityGroupsImpl object to access its operations. */
    private final NetworkSecurityGroupsImpl networkSecurityGroups;

    /**
     * Gets the NetworkSecurityGroupsImpl object to access its operations.
     *
     * @return the NetworkSecurityGroupsImpl object.
     */
    public NetworkSecurityGroupsImpl getNetworkSecurityGroups() {
        return this.networkSecurityGroups;
    }

    /** The SecurityRulesImpl object to access its operations. */
    private final SecurityRulesImpl securityRules;

    /**
     * Gets the SecurityRulesImpl object to access its operations.
     *
     * @return the SecurityRulesImpl object.
     */
    public SecurityRulesImpl getSecurityRules() {
        return this.securityRules;
    }

    /** The DefaultSecurityRulesImpl object to access its operations. */
    private final DefaultSecurityRulesImpl defaultSecurityRules;

    /**
     * Gets the DefaultSecurityRulesImpl object to access its operations.
     *
     * @return the DefaultSecurityRulesImpl object.
     */
    public DefaultSecurityRulesImpl getDefaultSecurityRules() {
        return this.defaultSecurityRules;
    }

    /** The NetworkVirtualAppliancesImpl object to access its operations. */
    private final NetworkVirtualAppliancesImpl networkVirtualAppliances;

    /**
     * Gets the NetworkVirtualAppliancesImpl object to access its operations.
     *
     * @return the NetworkVirtualAppliancesImpl object.
     */
    public NetworkVirtualAppliancesImpl getNetworkVirtualAppliances() {
        return this.networkVirtualAppliances;
    }

    /** The NetworkWatchersImpl object to access its operations. */
    private final NetworkWatchersImpl networkWatchers;

    /**
     * Gets the NetworkWatchersImpl object to access its operations.
     *
     * @return the NetworkWatchersImpl object.
     */
    public NetworkWatchersImpl getNetworkWatchers() {
        return this.networkWatchers;
    }

    /** The PacketCapturesImpl object to access its operations. */
    private final PacketCapturesImpl packetCaptures;

    /**
     * Gets the PacketCapturesImpl object to access its operations.
     *
     * @return the PacketCapturesImpl object.
     */
    public PacketCapturesImpl getPacketCaptures() {
        return this.packetCaptures;
    }

    /** The ConnectionMonitorsImpl object to access its operations. */
    private final ConnectionMonitorsImpl connectionMonitors;

    /**
     * Gets the ConnectionMonitorsImpl object to access its operations.
     *
     * @return the ConnectionMonitorsImpl object.
     */
    public ConnectionMonitorsImpl getConnectionMonitors() {
        return this.connectionMonitors;
    }

    /** The FlowLogsImpl object to access its operations. */
    private final FlowLogsImpl flowLogs;

    /**
     * Gets the FlowLogsImpl object to access its operations.
     *
     * @return the FlowLogsImpl object.
     */
    public FlowLogsImpl getFlowLogs() {
        return this.flowLogs;
    }

    /** The OperationsImpl object to access its operations. */
    private final OperationsImpl operations;

    /**
     * Gets the OperationsImpl object to access its operations.
     *
     * @return the OperationsImpl object.
     */
    public OperationsImpl getOperations() {
        return this.operations;
    }

    /** The PrivateEndpointsImpl object to access its operations. */
    private final PrivateEndpointsImpl privateEndpoints;

    /**
     * Gets the PrivateEndpointsImpl object to access its operations.
     *
     * @return the PrivateEndpointsImpl object.
     */
    public PrivateEndpointsImpl getPrivateEndpoints() {
        return this.privateEndpoints;
    }

    /** The AvailablePrivateEndpointTypesImpl object to access its operations. */
    private final AvailablePrivateEndpointTypesImpl availablePrivateEndpointTypes;

    /**
     * Gets the AvailablePrivateEndpointTypesImpl object to access its operations.
     *
     * @return the AvailablePrivateEndpointTypesImpl object.
     */
    public AvailablePrivateEndpointTypesImpl getAvailablePrivateEndpointTypes() {
        return this.availablePrivateEndpointTypes;
    }

    /** The PrivateDnsZoneGroupsImpl object to access its operations. */
    private final PrivateDnsZoneGroupsImpl privateDnsZoneGroups;

    /**
     * Gets the PrivateDnsZoneGroupsImpl object to access its operations.
     *
     * @return the PrivateDnsZoneGroupsImpl object.
     */
    public PrivateDnsZoneGroupsImpl getPrivateDnsZoneGroups() {
        return this.privateDnsZoneGroups;
    }

    /** The PrivateLinkServicesImpl object to access its operations. */
    private final PrivateLinkServicesImpl privateLinkServices;

    /**
     * Gets the PrivateLinkServicesImpl object to access its operations.
     *
     * @return the PrivateLinkServicesImpl object.
     */
    public PrivateLinkServicesImpl getPrivateLinkServices() {
        return this.privateLinkServices;
    }

    /** The PublicIpAddressesImpl object to access its operations. */
    private final PublicIpAddressesImpl publicIpAddresses;

    /**
     * Gets the PublicIpAddressesImpl object to access its operations.
     *
     * @return the PublicIpAddressesImpl object.
     */
    public PublicIpAddressesImpl getPublicIpAddresses() {
        return this.publicIpAddresses;
    }

    /** The PublicIpPrefixesImpl object to access its operations. */
    private final PublicIpPrefixesImpl publicIpPrefixes;

    /**
     * Gets the PublicIpPrefixesImpl object to access its operations.
     *
     * @return the PublicIpPrefixesImpl object.
     */
    public PublicIpPrefixesImpl getPublicIpPrefixes() {
        return this.publicIpPrefixes;
    }

    /** The RouteFiltersImpl object to access its operations. */
    private final RouteFiltersImpl routeFilters;

    /**
     * Gets the RouteFiltersImpl object to access its operations.
     *
     * @return the RouteFiltersImpl object.
     */
    public RouteFiltersImpl getRouteFilters() {
        return this.routeFilters;
    }

    /** The RouteFilterRulesImpl object to access its operations. */
    private final RouteFilterRulesImpl routeFilterRules;

    /**
     * Gets the RouteFilterRulesImpl object to access its operations.
     *
     * @return the RouteFilterRulesImpl object.
     */
    public RouteFilterRulesImpl getRouteFilterRules() {
        return this.routeFilterRules;
    }

    /** The RouteTablesImpl object to access its operations. */
    private final RouteTablesImpl routeTables;

    /**
     * Gets the RouteTablesImpl object to access its operations.
     *
     * @return the RouteTablesImpl object.
     */
    public RouteTablesImpl getRouteTables() {
        return this.routeTables;
    }

    /** The RoutesImpl object to access its operations. */
    private final RoutesImpl routes;

    /**
     * Gets the RoutesImpl object to access its operations.
     *
     * @return the RoutesImpl object.
     */
    public RoutesImpl getRoutes() {
        return this.routes;
    }

    /** The SecurityPartnerProvidersImpl object to access its operations. */
    private final SecurityPartnerProvidersImpl securityPartnerProviders;

    /**
     * Gets the SecurityPartnerProvidersImpl object to access its operations.
     *
     * @return the SecurityPartnerProvidersImpl object.
     */
    public SecurityPartnerProvidersImpl getSecurityPartnerProviders() {
        return this.securityPartnerProviders;
    }

    /** The BgpServiceCommunitiesImpl object to access its operations. */
    private final BgpServiceCommunitiesImpl bgpServiceCommunities;

    /**
     * Gets the BgpServiceCommunitiesImpl object to access its operations.
     *
     * @return the BgpServiceCommunitiesImpl object.
     */
    public BgpServiceCommunitiesImpl getBgpServiceCommunities() {
        return this.bgpServiceCommunities;
    }

    /** The ServiceEndpointPoliciesImpl object to access its operations. */
    private final ServiceEndpointPoliciesImpl serviceEndpointPolicies;

    /**
     * Gets the ServiceEndpointPoliciesImpl object to access its operations.
     *
     * @return the ServiceEndpointPoliciesImpl object.
     */
    public ServiceEndpointPoliciesImpl getServiceEndpointPolicies() {
        return this.serviceEndpointPolicies;
    }

    /** The ServiceEndpointPolicyDefinitionsImpl object to access its operations. */
    private final ServiceEndpointPolicyDefinitionsImpl serviceEndpointPolicyDefinitions;

    /**
     * Gets the ServiceEndpointPolicyDefinitionsImpl object to access its operations.
     *
     * @return the ServiceEndpointPolicyDefinitionsImpl object.
     */
    public ServiceEndpointPolicyDefinitionsImpl getServiceEndpointPolicyDefinitions() {
        return this.serviceEndpointPolicyDefinitions;
    }

    /** The ServiceTagsImpl object to access its operations. */
    private final ServiceTagsImpl serviceTags;

    /**
     * Gets the ServiceTagsImpl object to access its operations.
     *
     * @return the ServiceTagsImpl object.
     */
    public ServiceTagsImpl getServiceTags() {
        return this.serviceTags;
    }

    /** The UsagesImpl object to access its operations. */
    private final UsagesImpl usages;

    /**
     * Gets the UsagesImpl object to access its operations.
     *
     * @return the UsagesImpl object.
     */
    public UsagesImpl getUsages() {
        return this.usages;
    }

    /** The VirtualNetworksImpl object to access its operations. */
    private final VirtualNetworksImpl virtualNetworks;

    /**
     * Gets the VirtualNetworksImpl object to access its operations.
     *
     * @return the VirtualNetworksImpl object.
     */
    public VirtualNetworksImpl getVirtualNetworks() {
        return this.virtualNetworks;
    }

    /** The SubnetsImpl object to access its operations. */
    private final SubnetsImpl subnets;

    /**
     * Gets the SubnetsImpl object to access its operations.
     *
     * @return the SubnetsImpl object.
     */
    public SubnetsImpl getSubnets() {
        return this.subnets;
    }

    /** The ResourceNavigationLinksImpl object to access its operations. */
    private final ResourceNavigationLinksImpl resourceNavigationLinks;

    /**
     * Gets the ResourceNavigationLinksImpl object to access its operations.
     *
     * @return the ResourceNavigationLinksImpl object.
     */
    public ResourceNavigationLinksImpl getResourceNavigationLinks() {
        return this.resourceNavigationLinks;
    }

    /** The ServiceAssociationLinksImpl object to access its operations. */
    private final ServiceAssociationLinksImpl serviceAssociationLinks;

    /**
     * Gets the ServiceAssociationLinksImpl object to access its operations.
     *
     * @return the ServiceAssociationLinksImpl object.
     */
    public ServiceAssociationLinksImpl getServiceAssociationLinks() {
        return this.serviceAssociationLinks;
    }

    /** The VirtualNetworkPeeringsImpl object to access its operations. */
    private final VirtualNetworkPeeringsImpl virtualNetworkPeerings;

    /**
     * Gets the VirtualNetworkPeeringsImpl object to access its operations.
     *
     * @return the VirtualNetworkPeeringsImpl object.
     */
    public VirtualNetworkPeeringsImpl getVirtualNetworkPeerings() {
        return this.virtualNetworkPeerings;
    }

    /** The VirtualNetworkGatewaysImpl object to access its operations. */
    private final VirtualNetworkGatewaysImpl virtualNetworkGateways;

    /**
     * Gets the VirtualNetworkGatewaysImpl object to access its operations.
     *
     * @return the VirtualNetworkGatewaysImpl object.
     */
    public VirtualNetworkGatewaysImpl getVirtualNetworkGateways() {
        return this.virtualNetworkGateways;
    }

    /** The VirtualNetworkGatewayConnectionsImpl object to access its operations. */
    private final VirtualNetworkGatewayConnectionsImpl virtualNetworkGatewayConnections;

    /**
     * Gets the VirtualNetworkGatewayConnectionsImpl object to access its operations.
     *
     * @return the VirtualNetworkGatewayConnectionsImpl object.
     */
    public VirtualNetworkGatewayConnectionsImpl getVirtualNetworkGatewayConnections() {
        return this.virtualNetworkGatewayConnections;
    }

    /** The LocalNetworkGatewaysImpl object to access its operations. */
    private final LocalNetworkGatewaysImpl localNetworkGateways;

    /**
     * Gets the LocalNetworkGatewaysImpl object to access its operations.
     *
     * @return the LocalNetworkGatewaysImpl object.
     */
    public LocalNetworkGatewaysImpl getLocalNetworkGateways() {
        return this.localNetworkGateways;
    }

    /** The VirtualNetworkTapsImpl object to access its operations. */
    private final VirtualNetworkTapsImpl virtualNetworkTaps;

    /**
     * Gets the VirtualNetworkTapsImpl object to access its operations.
     *
     * @return the VirtualNetworkTapsImpl object.
     */
    public VirtualNetworkTapsImpl getVirtualNetworkTaps() {
        return this.virtualNetworkTaps;
    }

    /** The VirtualRoutersImpl object to access its operations. */
    private final VirtualRoutersImpl virtualRouters;

    /**
     * Gets the VirtualRoutersImpl object to access its operations.
     *
     * @return the VirtualRoutersImpl object.
     */
    public VirtualRoutersImpl getVirtualRouters() {
        return this.virtualRouters;
    }

    /** The VirtualRouterPeeringsImpl object to access its operations. */
    private final VirtualRouterPeeringsImpl virtualRouterPeerings;

    /**
     * Gets the VirtualRouterPeeringsImpl object to access its operations.
     *
     * @return the VirtualRouterPeeringsImpl object.
     */
    public VirtualRouterPeeringsImpl getVirtualRouterPeerings() {
        return this.virtualRouterPeerings;
    }

    /** The VirtualWansImpl object to access its operations. */
    private final VirtualWansImpl virtualWans;

    /**
     * Gets the VirtualWansImpl object to access its operations.
     *
     * @return the VirtualWansImpl object.
     */
    public VirtualWansImpl getVirtualWans() {
        return this.virtualWans;
    }

    /** The VpnSitesImpl object to access its operations. */
    private final VpnSitesImpl vpnSites;

    /**
     * Gets the VpnSitesImpl object to access its operations.
     *
     * @return the VpnSitesImpl object.
     */
    public VpnSitesImpl getVpnSites() {
        return this.vpnSites;
    }

    /** The VpnSiteLinksImpl object to access its operations. */
    private final VpnSiteLinksImpl vpnSiteLinks;

    /**
     * Gets the VpnSiteLinksImpl object to access its operations.
     *
     * @return the VpnSiteLinksImpl object.
     */
    public VpnSiteLinksImpl getVpnSiteLinks() {
        return this.vpnSiteLinks;
    }

    /** The VpnSitesConfigurationsImpl object to access its operations. */
    private final VpnSitesConfigurationsImpl vpnSitesConfigurations;

    /**
     * Gets the VpnSitesConfigurationsImpl object to access its operations.
     *
     * @return the VpnSitesConfigurationsImpl object.
     */
    public VpnSitesConfigurationsImpl getVpnSitesConfigurations() {
        return this.vpnSitesConfigurations;
    }

    /** The VpnServerConfigurationsImpl object to access its operations. */
    private final VpnServerConfigurationsImpl vpnServerConfigurations;

    /**
     * Gets the VpnServerConfigurationsImpl object to access its operations.
     *
     * @return the VpnServerConfigurationsImpl object.
     */
    public VpnServerConfigurationsImpl getVpnServerConfigurations() {
        return this.vpnServerConfigurations;
    }

    /** The VirtualHubsImpl object to access its operations. */
    private final VirtualHubsImpl virtualHubs;

    /**
     * Gets the VirtualHubsImpl object to access its operations.
     *
     * @return the VirtualHubsImpl object.
     */
    public VirtualHubsImpl getVirtualHubs() {
        return this.virtualHubs;
    }

    /** The HubVirtualNetworkConnectionsImpl object to access its operations. */
    private final HubVirtualNetworkConnectionsImpl hubVirtualNetworkConnections;

    /**
     * Gets the HubVirtualNetworkConnectionsImpl object to access its operations.
     *
     * @return the HubVirtualNetworkConnectionsImpl object.
     */
    public HubVirtualNetworkConnectionsImpl getHubVirtualNetworkConnections() {
        return this.hubVirtualNetworkConnections;
    }

    /** The VpnGatewaysImpl object to access its operations. */
    private final VpnGatewaysImpl vpnGateways;

    /**
     * Gets the VpnGatewaysImpl object to access its operations.
     *
     * @return the VpnGatewaysImpl object.
     */
    public VpnGatewaysImpl getVpnGateways() {
        return this.vpnGateways;
    }

    /** The VpnConnectionsImpl object to access its operations. */
    private final VpnConnectionsImpl vpnConnections;

    /**
     * Gets the VpnConnectionsImpl object to access its operations.
     *
     * @return the VpnConnectionsImpl object.
     */
    public VpnConnectionsImpl getVpnConnections() {
        return this.vpnConnections;
    }

    /** The VpnSiteLinkConnectionsImpl object to access its operations. */
    private final VpnSiteLinkConnectionsImpl vpnSiteLinkConnections;

    /**
     * Gets the VpnSiteLinkConnectionsImpl object to access its operations.
     *
     * @return the VpnSiteLinkConnectionsImpl object.
     */
    public VpnSiteLinkConnectionsImpl getVpnSiteLinkConnections() {
        return this.vpnSiteLinkConnections;
    }

    /** The VpnLinkConnectionsImpl object to access its operations. */
    private final VpnLinkConnectionsImpl vpnLinkConnections;

    /**
     * Gets the VpnLinkConnectionsImpl object to access its operations.
     *
     * @return the VpnLinkConnectionsImpl object.
     */
    public VpnLinkConnectionsImpl getVpnLinkConnections() {
        return this.vpnLinkConnections;
    }

    /** The P2SVpnGatewaysImpl object to access its operations. */
    private final P2SVpnGatewaysImpl p2SVpnGateways;

    /**
     * Gets the P2SVpnGatewaysImpl object to access its operations.
     *
     * @return the P2SVpnGatewaysImpl object.
     */
    public P2SVpnGatewaysImpl getP2SVpnGateways() {
        return this.p2SVpnGateways;
    }

    /** The VpnServerConfigurationsAssociatedWithVirtualWansImpl object to access its operations. */
    private final VpnServerConfigurationsAssociatedWithVirtualWansImpl vpnServerConfigurationsAssociatedWithVirtualWans;

    /**
     * Gets the VpnServerConfigurationsAssociatedWithVirtualWansImpl object to access its operations.
     *
     * @return the VpnServerConfigurationsAssociatedWithVirtualWansImpl object.
     */
    public VpnServerConfigurationsAssociatedWithVirtualWansImpl getVpnServerConfigurationsAssociatedWithVirtualWans() {
        return this.vpnServerConfigurationsAssociatedWithVirtualWans;
    }

    /** The VirtualHubRouteTableV2SImpl object to access its operations. */
    private final VirtualHubRouteTableV2SImpl virtualHubRouteTableV2S;

    /**
     * Gets the VirtualHubRouteTableV2SImpl object to access its operations.
     *
     * @return the VirtualHubRouteTableV2SImpl object.
     */
    public VirtualHubRouteTableV2SImpl getVirtualHubRouteTableV2S() {
        return this.virtualHubRouteTableV2S;
    }

    /** The ExpressRouteGatewaysImpl object to access its operations. */
    private final ExpressRouteGatewaysImpl expressRouteGateways;

    /**
     * Gets the ExpressRouteGatewaysImpl object to access its operations.
     *
     * @return the ExpressRouteGatewaysImpl object.
     */
    public ExpressRouteGatewaysImpl getExpressRouteGateways() {
        return this.expressRouteGateways;
    }

    /** The ExpressRouteConnectionsImpl object to access its operations. */
    private final ExpressRouteConnectionsImpl expressRouteConnections;

    /**
     * Gets the ExpressRouteConnectionsImpl object to access its operations.
     *
     * @return the ExpressRouteConnectionsImpl object.
     */
    public ExpressRouteConnectionsImpl getExpressRouteConnections() {
        return this.expressRouteConnections;
    }

    /** The HubRouteTablesImpl object to access its operations. */
    private final HubRouteTablesImpl hubRouteTables;

    /**
     * Gets the HubRouteTablesImpl object to access its operations.
     *
     * @return the HubRouteTablesImpl object.
     */
    public HubRouteTablesImpl getHubRouteTables() {
        return this.hubRouteTables;
    }

    /** The WebApplicationFirewallPoliciesImpl object to access its operations. */
    private final WebApplicationFirewallPoliciesImpl webApplicationFirewallPolicies;

    /**
     * Gets the WebApplicationFirewallPoliciesImpl object to access its operations.
     *
     * @return the WebApplicationFirewallPoliciesImpl object.
     */
    public WebApplicationFirewallPoliciesImpl getWebApplicationFirewallPolicies() {
        return this.webApplicationFirewallPolicies;
    }

    /** Initializes an instance of NetworkManagementClient client. */
    public NetworkManagementClientImpl() {
        this(
            new HttpPipelineBuilder().policies(new UserAgentPolicy(), new RetryPolicy(), new CookiePolicy()).build(),
            AzureEnvironment.AZURE);
    }

    /**
     * Initializes an instance of NetworkManagementClient client.
     *
     * @param httpPipeline The HTTP pipeline to send requests through.
     */
    public NetworkManagementClientImpl(HttpPipeline httpPipeline) {
        this(httpPipeline, AzureEnvironment.AZURE);
    }

    /**
     * Initializes an instance of NetworkManagementClient client.
     *
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param environment The Azure environment.
     */
    public NetworkManagementClientImpl(HttpPipeline httpPipeline, AzureEnvironment environment) {
        super(httpPipeline, environment);
        this.httpPipeline = httpPipeline;
        this.applicationGateways = new ApplicationGatewaysImpl(this);
        this.applicationSecurityGroups = new ApplicationSecurityGroupsImpl(this);
        this.availableDelegations = new AvailableDelegationsImpl(this);
        this.availableResourceGroupDelegations = new AvailableResourceGroupDelegationsImpl(this);
        this.availableServiceAliases = new AvailableServiceAliasesImpl(this);
        this.azureFirewalls = new AzureFirewallsImpl(this);
        this.azureFirewallFqdnTags = new AzureFirewallFqdnTagsImpl(this);
        this.bastionHosts = new BastionHostsImpl(this);
        this.ddosCustomPolicies = new DdosCustomPoliciesImpl(this);
        this.ddosProtectionPlans = new DdosProtectionPlansImpl(this);
        this.availableEndpointServices = new AvailableEndpointServicesImpl(this);
        this.expressRouteCircuitAuthorizations = new ExpressRouteCircuitAuthorizationsImpl(this);
        this.expressRouteCircuitPeerings = new ExpressRouteCircuitPeeringsImpl(this);
        this.expressRouteCircuitConnections = new ExpressRouteCircuitConnectionsImpl(this);
        this.peerExpressRouteCircuitConnections = new PeerExpressRouteCircuitConnectionsImpl(this);
        this.expressRouteCircuits = new ExpressRouteCircuitsImpl(this);
        this.expressRouteServiceProviders = new ExpressRouteServiceProvidersImpl(this);
        this.expressRouteCrossConnections = new ExpressRouteCrossConnectionsImpl(this);
        this.expressRouteCrossConnectionPeerings = new ExpressRouteCrossConnectionPeeringsImpl(this);
        this.expressRoutePortsLocations = new ExpressRoutePortsLocationsImpl(this);
        this.expressRoutePorts = new ExpressRoutePortsImpl(this);
        this.expressRouteLinks = new ExpressRouteLinksImpl(this);
        this.firewallPolicies = new FirewallPoliciesImpl(this);
        this.firewallPolicyRuleGroups = new FirewallPolicyRuleGroupsImpl(this);
        this.ipAllocations = new IpAllocationsImpl(this);
        this.ipGroups = new IpGroupsImpl(this);
        this.loadBalancers = new LoadBalancersImpl(this);
        this.loadBalancerBackendAddressPools = new LoadBalancerBackendAddressPoolsImpl(this);
        this.loadBalancerFrontendIpConfigurations = new LoadBalancerFrontendIpConfigurationsImpl(this);
        this.inboundNatRules = new InboundNatRulesImpl(this);
        this.loadBalancerLoadBalancingRules = new LoadBalancerLoadBalancingRulesImpl(this);
        this.loadBalancerOutboundRules = new LoadBalancerOutboundRulesImpl(this);
        this.loadBalancerNetworkInterfaces = new LoadBalancerNetworkInterfacesImpl(this);
        this.loadBalancerProbes = new LoadBalancerProbesImpl(this);
        this.natGateways = new NatGatewaysImpl(this);
        this.networkInterfaces = new NetworkInterfacesImpl(this);
        this.networkInterfaceIpConfigurations = new NetworkInterfaceIpConfigurationsImpl(this);
        this.networkInterfaceLoadBalancers = new NetworkInterfaceLoadBalancersImpl(this);
        this.networkInterfaceTapConfigurations = new NetworkInterfaceTapConfigurationsImpl(this);
        this.networkProfiles = new NetworkProfilesImpl(this);
        this.networkSecurityGroups = new NetworkSecurityGroupsImpl(this);
        this.securityRules = new SecurityRulesImpl(this);
        this.defaultSecurityRules = new DefaultSecurityRulesImpl(this);
        this.networkVirtualAppliances = new NetworkVirtualAppliancesImpl(this);
        this.networkWatchers = new NetworkWatchersImpl(this);
        this.packetCaptures = new PacketCapturesImpl(this);
        this.connectionMonitors = new ConnectionMonitorsImpl(this);
        this.flowLogs = new FlowLogsImpl(this);
        this.operations = new OperationsImpl(this);
        this.privateEndpoints = new PrivateEndpointsImpl(this);
        this.availablePrivateEndpointTypes = new AvailablePrivateEndpointTypesImpl(this);
        this.privateDnsZoneGroups = new PrivateDnsZoneGroupsImpl(this);
        this.privateLinkServices = new PrivateLinkServicesImpl(this);
        this.publicIpAddresses = new PublicIpAddressesImpl(this);
        this.publicIpPrefixes = new PublicIpPrefixesImpl(this);
        this.routeFilters = new RouteFiltersImpl(this);
        this.routeFilterRules = new RouteFilterRulesImpl(this);
        this.routeTables = new RouteTablesImpl(this);
        this.routes = new RoutesImpl(this);
        this.securityPartnerProviders = new SecurityPartnerProvidersImpl(this);
        this.bgpServiceCommunities = new BgpServiceCommunitiesImpl(this);
        this.serviceEndpointPolicies = new ServiceEndpointPoliciesImpl(this);
        this.serviceEndpointPolicyDefinitions = new ServiceEndpointPolicyDefinitionsImpl(this);
        this.serviceTags = new ServiceTagsImpl(this);
        this.usages = new UsagesImpl(this);
        this.virtualNetworks = new VirtualNetworksImpl(this);
        this.subnets = new SubnetsImpl(this);
        this.resourceNavigationLinks = new ResourceNavigationLinksImpl(this);
        this.serviceAssociationLinks = new ServiceAssociationLinksImpl(this);
        this.virtualNetworkPeerings = new VirtualNetworkPeeringsImpl(this);
        this.virtualNetworkGateways = new VirtualNetworkGatewaysImpl(this);
        this.virtualNetworkGatewayConnections = new VirtualNetworkGatewayConnectionsImpl(this);
        this.localNetworkGateways = new LocalNetworkGatewaysImpl(this);
        this.virtualNetworkTaps = new VirtualNetworkTapsImpl(this);
        this.virtualRouters = new VirtualRoutersImpl(this);
        this.virtualRouterPeerings = new VirtualRouterPeeringsImpl(this);
        this.virtualWans = new VirtualWansImpl(this);
        this.vpnSites = new VpnSitesImpl(this);
        this.vpnSiteLinks = new VpnSiteLinksImpl(this);
        this.vpnSitesConfigurations = new VpnSitesConfigurationsImpl(this);
        this.vpnServerConfigurations = new VpnServerConfigurationsImpl(this);
        this.virtualHubs = new VirtualHubsImpl(this);
        this.hubVirtualNetworkConnections = new HubVirtualNetworkConnectionsImpl(this);
        this.vpnGateways = new VpnGatewaysImpl(this);
        this.vpnConnections = new VpnConnectionsImpl(this);
        this.vpnSiteLinkConnections = new VpnSiteLinkConnectionsImpl(this);
        this.vpnLinkConnections = new VpnLinkConnectionsImpl(this);
        this.p2SVpnGateways = new P2SVpnGatewaysImpl(this);
        this.vpnServerConfigurationsAssociatedWithVirtualWans =
            new VpnServerConfigurationsAssociatedWithVirtualWansImpl(this);
        this.virtualHubRouteTableV2S = new VirtualHubRouteTableV2SImpl(this);
        this.expressRouteGateways = new ExpressRouteGatewaysImpl(this);
        this.expressRouteConnections = new ExpressRouteConnectionsImpl(this);
        this.hubRouteTables = new HubRouteTablesImpl(this);
        this.webApplicationFirewallPolicies = new WebApplicationFirewallPoliciesImpl(this);
        this.service =
            RestProxy.create(NetworkManagementClientService.class, this.httpPipeline, this.getSerializerAdapter());
    }

    /**
     * The interface defining all the services for NetworkManagementClient to be used by the proxy service to perform
     * REST calls.
     */
    @Host("{$host}")
    @ServiceInterface(name = "NetworkManagementCli")
    private interface NetworkManagementClientService {
        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Post(
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network"
                + "/bastionHosts/{bastionHostName}/createShareableLinks")
        @ExpectedResponses({200, 202})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> putBastionShareableLink(
            @HostParam("$host") String host,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("bastionHostName") String bastionHostname,
            @QueryParam("api-version") String apiVersion,
            @PathParam("subscriptionId") String subscriptionId,
            @BodyParam("application/json") BastionShareableLinkListRequest bslRequest,
            Context context);

        @Headers({"Accept: application/json;q=0.9", "Content-Type: application/json"})
        @Post(
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network"
                + "/bastionHosts/{bastionHostName}/deleteShareableLinks")
        @ExpectedResponses({200, 202})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> deleteBastionShareableLink(
            @HostParam("$host") String host,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("bastionHostName") String bastionHostname,
            @QueryParam("api-version") String apiVersion,
            @PathParam("subscriptionId") String subscriptionId,
            @BodyParam("application/json") BastionShareableLinkListRequest bslRequest,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Post(
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network"
                + "/bastionHosts/{bastionHostName}/getShareableLinks")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<BastionShareableLinkListResult>> getBastionShareableLink(
            @HostParam("$host") String host,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("bastionHostName") String bastionHostname,
            @QueryParam("api-version") String apiVersion,
            @PathParam("subscriptionId") String subscriptionId,
            @BodyParam("application/json") BastionShareableLinkListRequest bslRequest,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Post(
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network"
                + "/bastionHosts/{bastionHostName}/getActiveSessions")
        @ExpectedResponses({200, 202})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> getActiveSessions(
            @HostParam("$host") String host,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("bastionHostName") String bastionHostname,
            @QueryParam("api-version") String apiVersion,
            @PathParam("subscriptionId") String subscriptionId,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Post(
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network"
                + "/bastionHosts/{bastionHostName}/disconnectActiveSessions")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<BastionSessionDeleteResult>> disconnectActiveSessions(
            @HostParam("$host") String host,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("bastionHostName") String bastionHostname,
            @QueryParam("api-version") String apiVersion,
            @PathParam("subscriptionId") String subscriptionId,
            @BodyParam("application/json") SessionIds sessionIds,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get(
            "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/CheckDnsNameAvailability")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<DnsNameAvailabilityResult>> checkDnsNameAvailability(
            @HostParam("$host") String host,
            @PathParam("location") String location,
            @QueryParam("domainNameLabel") String domainNameLabel,
            @QueryParam("api-version") String apiVersion,
            @PathParam("subscriptionId") String subscriptionId,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get(
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans"
                + "/{virtualWANName}/supportedSecurityProviders")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<VirtualWanSecurityProviders>> supportedSecurityProviders(
            @HostParam("$host") String host,
            @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("virtualWANName") String virtualWanName,
            @QueryParam("api-version") String apiVersion,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Post(
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans"
                + "/{virtualWANName}/GenerateVpnProfile")
        @ExpectedResponses({200, 202})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> generatevirtualwanvpnserverconfigurationvpnprofile(
            @HostParam("$host") String host,
            @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("virtualWANName") String virtualWanName,
            @QueryParam("api-version") String apiVersion,
            @BodyParam("application/json") VirtualWanVpnProfileParameters vpnClientParams,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Post(
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network"
                + "/bastionHosts/{bastionHostName}/createShareableLinks")
        @ExpectedResponses({200, 202})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<BastionShareableLinkListResult>> beginPutBastionShareableLinkWithoutPolling(
            @HostParam("$host") String host,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("bastionHostName") String bastionHostname,
            @QueryParam("api-version") String apiVersion,
            @PathParam("subscriptionId") String subscriptionId,
            @BodyParam("application/json") BastionShareableLinkListRequest bslRequest,
            Context context);

        @Headers({"Accept: application/json;q=0.9", "Content-Type: application/json"})
        @Post(
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network"
                + "/bastionHosts/{bastionHostName}/deleteShareableLinks")
        @ExpectedResponses({200, 202})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Void>> beginDeleteBastionShareableLinkWithoutPolling(
            @HostParam("$host") String host,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("bastionHostName") String bastionHostname,
            @QueryParam("api-version") String apiVersion,
            @PathParam("subscriptionId") String subscriptionId,
            @BodyParam("application/json") BastionShareableLinkListRequest bslRequest,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Post(
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network"
                + "/bastionHosts/{bastionHostName}/getActiveSessions")
        @ExpectedResponses({200, 202})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<BastionActiveSessionListResult>> beginGetActiveSessionsWithoutPolling(
            @HostParam("$host") String host,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("bastionHostName") String bastionHostname,
            @QueryParam("api-version") String apiVersion,
            @PathParam("subscriptionId") String subscriptionId,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Post(
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans"
                + "/{virtualWANName}/GenerateVpnProfile")
        @ExpectedResponses({200, 202})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<VpnProfileResponse>> beginGeneratevirtualwanvpnserverconfigurationvpnprofileWithoutPolling(
            @HostParam("$host") String host,
            @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("virtualWANName") String virtualWanName,
            @QueryParam("api-version") String apiVersion,
            @BodyParam("application/json") VirtualWanVpnProfileParameters vpnClientParams,
            Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<BastionShareableLinkListResult>> getBastionShareableLinkNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, Context context);

        @Headers({"Accept: application/json", "Content-Type: application/json"})
        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<BastionSessionDeleteResult>> disconnectActiveSessionsNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, Context context);
    }

    /**
     * Creates a Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for all the Bastion Shareable Link endpoints.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Flux<ByteBuffer>>> putBastionShareableLinkWithResponseAsync(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (bastionHostname == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter bastionHostname is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (vms != null) {
            vms.forEach(e -> e.validate());
        }
        final String apiVersion = "2020-04-01";
        BastionShareableLinkListRequest bslRequest = new BastionShareableLinkListRequest();
        bslRequest.setVms(vms);
        return FluxUtil
            .withContext(
                context ->
                    service
                        .putBastionShareableLink(
                            this.getHost(),
                            resourceGroupName,
                            bastionHostname,
                            apiVersion,
                            this.getSubscriptionId(),
                            bslRequest,
                            context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Creates a Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for all the Bastion Shareable Link endpoints.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Flux<ByteBuffer>>> putBastionShareableLinkWithResponseAsync(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms, Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (bastionHostname == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter bastionHostname is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (vms != null) {
            vms.forEach(e -> e.validate());
        }
        final String apiVersion = "2020-04-01";
        BastionShareableLinkListRequest bslRequest = new BastionShareableLinkListRequest();
        bslRequest.setVms(vms);
        return service
            .putBastionShareableLink(
                this.getHost(),
                resourceGroupName,
                bastionHostname,
                apiVersion,
                this.getSubscriptionId(),
                bslRequest,
                context);
    }

    /**
     * Creates a Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for all the Bastion Shareable Link endpoints.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PollerFlux<PollResult<BastionShareableLinkListResult>, BastionShareableLinkListResult>
        beginPutBastionShareableLink(String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms) {
        Mono<Response<Flux<ByteBuffer>>> mono =
            putBastionShareableLinkWithResponseAsync(resourceGroupName, bastionHostname, vms);
        return this
            .<BastionShareableLinkListResult, BastionShareableLinkListResult>getLroResultAsync(
                mono,
                this.getHttpPipeline(),
                BastionShareableLinkListResult.class,
                BastionShareableLinkListResult.class);
    }

    /**
     * Creates a Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for all the Bastion Shareable Link endpoints.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PollerFlux<PollResult<BastionShareableLinkListResult>, BastionShareableLinkListResult>
        beginPutBastionShareableLink(
            String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms, Context context) {
        Mono<Response<Flux<ByteBuffer>>> mono =
            putBastionShareableLinkWithResponseAsync(resourceGroupName, bastionHostname, vms, context);
        return this
            .<BastionShareableLinkListResult, BastionShareableLinkListResult>getLroResultAsync(
                mono,
                this.getHttpPipeline(),
                BastionShareableLinkListResult.class,
                BastionShareableLinkListResult.class);
    }

    /**
     * Creates a Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for all the Bastion Shareable Link endpoints.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BastionShareableLinkListResult> putBastionShareableLinkAsync(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms) {
        Mono<Response<Flux<ByteBuffer>>> mono =
            putBastionShareableLinkWithResponseAsync(resourceGroupName, bastionHostname, vms);
        return this
            .<BastionShareableLinkListResult, BastionShareableLinkListResult>getLroResultAsync(
                mono,
                this.getHttpPipeline(),
                BastionShareableLinkListResult.class,
                BastionShareableLinkListResult.class)
            .last()
            .flatMap(AsyncPollResponse::getFinalResult);
    }

    /**
     * Creates a Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for all the Bastion Shareable Link endpoints.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BastionShareableLinkListResult> putBastionShareableLinkAsync(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms, Context context) {
        Mono<Response<Flux<ByteBuffer>>> mono =
            putBastionShareableLinkWithResponseAsync(resourceGroupName, bastionHostname, vms, context);
        return this
            .<BastionShareableLinkListResult, BastionShareableLinkListResult>getLroResultAsync(
                mono,
                this.getHttpPipeline(),
                BastionShareableLinkListResult.class,
                BastionShareableLinkListResult.class)
            .last()
            .flatMap(AsyncPollResponse::getFinalResult);
    }

    /**
     * Creates a Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for all the Bastion Shareable Link endpoints.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BastionShareableLinkListResult putBastionShareableLink(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms) {
        return putBastionShareableLinkAsync(resourceGroupName, bastionHostname, vms).block();
    }

    /**
     * Creates a Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for all the Bastion Shareable Link endpoints.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BastionShareableLinkListResult putBastionShareableLink(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms, Context context) {
        return putBastionShareableLinkAsync(resourceGroupName, bastionHostname, vms, context).block();
    }

    /**
     * Deletes the Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Flux<ByteBuffer>>> deleteBastionShareableLinkWithResponseAsync(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (bastionHostname == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter bastionHostname is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (vms != null) {
            vms.forEach(e -> e.validate());
        }
        final String apiVersion = "2020-04-01";
        BastionShareableLinkListRequest bslRequest = new BastionShareableLinkListRequest();
        bslRequest.setVms(vms);
        return FluxUtil
            .withContext(
                context ->
                    service
                        .deleteBastionShareableLink(
                            this.getHost(),
                            resourceGroupName,
                            bastionHostname,
                            apiVersion,
                            this.getSubscriptionId(),
                            bslRequest,
                            context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Deletes the Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Flux<ByteBuffer>>> deleteBastionShareableLinkWithResponseAsync(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms, Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (bastionHostname == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter bastionHostname is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (vms != null) {
            vms.forEach(e -> e.validate());
        }
        final String apiVersion = "2020-04-01";
        BastionShareableLinkListRequest bslRequest = new BastionShareableLinkListRequest();
        bslRequest.setVms(vms);
        return service
            .deleteBastionShareableLink(
                this.getHost(),
                resourceGroupName,
                bastionHostname,
                apiVersion,
                this.getSubscriptionId(),
                bslRequest,
                context);
    }

    /**
     * Deletes the Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PollerFlux<PollResult<Void>, Void> beginDeleteBastionShareableLink(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms) {
        Mono<Response<Flux<ByteBuffer>>> mono =
            deleteBastionShareableLinkWithResponseAsync(resourceGroupName, bastionHostname, vms);
        return this.<Void, Void>getLroResultAsync(mono, this.getHttpPipeline(), Void.class, Void.class);
    }

    /**
     * Deletes the Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PollerFlux<PollResult<Void>, Void> beginDeleteBastionShareableLink(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms, Context context) {
        Mono<Response<Flux<ByteBuffer>>> mono =
            deleteBastionShareableLinkWithResponseAsync(resourceGroupName, bastionHostname, vms, context);
        return this.<Void, Void>getLroResultAsync(mono, this.getHttpPipeline(), Void.class, Void.class);
    }

    /**
     * Deletes the Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteBastionShareableLinkAsync(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms) {
        Mono<Response<Flux<ByteBuffer>>> mono =
            deleteBastionShareableLinkWithResponseAsync(resourceGroupName, bastionHostname, vms);
        return this
            .<Void, Void>getLroResultAsync(mono, this.getHttpPipeline(), Void.class, Void.class)
            .last()
            .flatMap(AsyncPollResponse::getFinalResult);
    }

    /**
     * Deletes the Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteBastionShareableLinkAsync(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms, Context context) {
        Mono<Response<Flux<ByteBuffer>>> mono =
            deleteBastionShareableLinkWithResponseAsync(resourceGroupName, bastionHostname, vms, context);
        return this
            .<Void, Void>getLroResultAsync(mono, this.getHttpPipeline(), Void.class, Void.class)
            .last()
            .flatMap(AsyncPollResponse::getFinalResult);
    }

    /**
     * Deletes the Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteBastionShareableLink(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms) {
        deleteBastionShareableLinkAsync(resourceGroupName, bastionHostname, vms).block();
    }

    /**
     * Deletes the Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteBastionShareableLink(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms, Context context) {
        deleteBastionShareableLinkAsync(resourceGroupName, bastionHostname, vms, context).block();
    }

    /**
     * Return the Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for all the Bastion Shareable Link endpoints.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BastionShareableLink>> getBastionShareableLinkSinglePageAsync(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (bastionHostname == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter bastionHostname is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (vms != null) {
            vms.forEach(e -> e.validate());
        }
        final String apiVersion = "2020-04-01";
        BastionShareableLinkListRequest bslRequest = new BastionShareableLinkListRequest();
        bslRequest.setVms(vms);
        return FluxUtil
            .withContext(
                context ->
                    service
                        .getBastionShareableLink(
                            this.getHost(),
                            resourceGroupName,
                            bastionHostname,
                            apiVersion,
                            this.getSubscriptionId(),
                            bslRequest,
                            context))
            .<PagedResponse<BastionShareableLink>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().getValue(),
                        res.getValue().getNextLink(),
                        null))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Return the Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for all the Bastion Shareable Link endpoints.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BastionShareableLink>> getBastionShareableLinkSinglePageAsync(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms, Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (bastionHostname == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter bastionHostname is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (vms != null) {
            vms.forEach(e -> e.validate());
        }
        final String apiVersion = "2020-04-01";
        BastionShareableLinkListRequest bslRequest = new BastionShareableLinkListRequest();
        bslRequest.setVms(vms);
        return service
            .getBastionShareableLink(
                this.getHost(),
                resourceGroupName,
                bastionHostname,
                apiVersion,
                this.getSubscriptionId(),
                bslRequest,
                context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().getValue(),
                        res.getValue().getNextLink(),
                        null));
    }

    /**
     * Return the Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for all the Bastion Shareable Link endpoints.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BastionShareableLink> getBastionShareableLinkAsync(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms) {
        return new PagedFlux<>(
            () -> getBastionShareableLinkSinglePageAsync(resourceGroupName, bastionHostname, vms),
            nextLink -> getBastionShareableLinkNextSinglePageAsync(nextLink));
    }

    /**
     * Return the Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for all the Bastion Shareable Link endpoints.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BastionShareableLink> getBastionShareableLinkAsync(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms, Context context) {
        return new PagedFlux<>(
            () -> getBastionShareableLinkSinglePageAsync(resourceGroupName, bastionHostname, vms, context),
            nextLink -> getBastionShareableLinkNextSinglePageAsync(nextLink));
    }

    /**
     * Return the Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for all the Bastion Shareable Link endpoints.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BastionShareableLink> getBastionShareableLink(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms) {
        return new PagedIterable<>(getBastionShareableLinkAsync(resourceGroupName, bastionHostname, vms));
    }

    /**
     * Return the Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for all the Bastion Shareable Link endpoints.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BastionShareableLink> getBastionShareableLink(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms, Context context) {
        return new PagedIterable<>(getBastionShareableLinkAsync(resourceGroupName, bastionHostname, vms, context));
    }

    /**
     * Returns the list of currently active sessions on the Bastion.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for GetActiveSessions.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Flux<ByteBuffer>>> getActiveSessionsWithResponseAsync(
        String resourceGroupName, String bastionHostname) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (bastionHostname == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter bastionHostname is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        final String apiVersion = "2020-04-01";
        return FluxUtil
            .withContext(
                context ->
                    service
                        .getActiveSessions(
                            this.getHost(),
                            resourceGroupName,
                            bastionHostname,
                            apiVersion,
                            this.getSubscriptionId(),
                            context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Returns the list of currently active sessions on the Bastion.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for GetActiveSessions.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Flux<ByteBuffer>>> getActiveSessionsWithResponseAsync(
        String resourceGroupName, String bastionHostname, Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (bastionHostname == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter bastionHostname is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        final String apiVersion = "2020-04-01";
        return service
            .getActiveSessions(
                this.getHost(), resourceGroupName, bastionHostname, apiVersion, this.getSubscriptionId(), context);
    }

    /**
     * Returns the list of currently active sessions on the Bastion.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for GetActiveSessions.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PollerFlux<PollResult<BastionActiveSessionListResult>, BastionActiveSessionListResult>
        beginGetActiveSessions(String resourceGroupName, String bastionHostname) {
        Mono<Response<Flux<ByteBuffer>>> mono = getActiveSessionsWithResponseAsync(resourceGroupName, bastionHostname);
        return this
            .<BastionActiveSessionListResult, BastionActiveSessionListResult>getLroResultAsync(
                mono,
                this.getHttpPipeline(),
                BastionActiveSessionListResult.class,
                BastionActiveSessionListResult.class);
    }

    /**
     * Returns the list of currently active sessions on the Bastion.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for GetActiveSessions.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PollerFlux<PollResult<BastionActiveSessionListResult>, BastionActiveSessionListResult>
        beginGetActiveSessions(String resourceGroupName, String bastionHostname, Context context) {
        Mono<Response<Flux<ByteBuffer>>> mono =
            getActiveSessionsWithResponseAsync(resourceGroupName, bastionHostname, context);
        return this
            .<BastionActiveSessionListResult, BastionActiveSessionListResult>getLroResultAsync(
                mono,
                this.getHttpPipeline(),
                BastionActiveSessionListResult.class,
                BastionActiveSessionListResult.class);
    }

    /**
     * Returns the list of currently active sessions on the Bastion.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for GetActiveSessions.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BastionActiveSessionListResult> getActiveSessionsAsync(
        String resourceGroupName, String bastionHostname) {
        Mono<Response<Flux<ByteBuffer>>> mono = getActiveSessionsWithResponseAsync(resourceGroupName, bastionHostname);
        return this
            .<BastionActiveSessionListResult, BastionActiveSessionListResult>getLroResultAsync(
                mono,
                this.getHttpPipeline(),
                BastionActiveSessionListResult.class,
                BastionActiveSessionListResult.class)
            .last()
            .flatMap(AsyncPollResponse::getFinalResult);
    }

    /**
     * Returns the list of currently active sessions on the Bastion.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for GetActiveSessions.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BastionActiveSessionListResult> getActiveSessionsAsync(
        String resourceGroupName, String bastionHostname, Context context) {
        Mono<Response<Flux<ByteBuffer>>> mono =
            getActiveSessionsWithResponseAsync(resourceGroupName, bastionHostname, context);
        return this
            .<BastionActiveSessionListResult, BastionActiveSessionListResult>getLroResultAsync(
                mono,
                this.getHttpPipeline(),
                BastionActiveSessionListResult.class,
                BastionActiveSessionListResult.class)
            .last()
            .flatMap(AsyncPollResponse::getFinalResult);
    }

    /**
     * Returns the list of currently active sessions on the Bastion.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for GetActiveSessions.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BastionActiveSessionListResult getActiveSessions(String resourceGroupName, String bastionHostname) {
        return getActiveSessionsAsync(resourceGroupName, bastionHostname).block();
    }

    /**
     * Returns the list of currently active sessions on the Bastion.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for GetActiveSessions.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BastionActiveSessionListResult getActiveSessions(
        String resourceGroupName, String bastionHostname, Context context) {
        return getActiveSessionsAsync(resourceGroupName, bastionHostname, context).block();
    }

    /**
     * Returns the list of currently active sessions on the Bastion.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param sessionIdsSessionIds List of session IDs.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for DisconnectActiveSessions.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BastionSessionState>> disconnectActiveSessionsSinglePageAsync(
        String resourceGroupName, String bastionHostname, List<String> sessionIdsSessionIds) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (bastionHostname == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter bastionHostname is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        final String apiVersion = "2020-04-01";
        SessionIds sessionIds = new SessionIds();
        sessionIds.setSessionIds(sessionIdsSessionIds);
        return FluxUtil
            .withContext(
                context ->
                    service
                        .disconnectActiveSessions(
                            this.getHost(),
                            resourceGroupName,
                            bastionHostname,
                            apiVersion,
                            this.getSubscriptionId(),
                            sessionIds,
                            context))
            .<PagedResponse<BastionSessionState>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().getValue(),
                        res.getValue().getNextLink(),
                        null))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Returns the list of currently active sessions on the Bastion.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param sessionIdsSessionIds List of session IDs.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for DisconnectActiveSessions.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BastionSessionState>> disconnectActiveSessionsSinglePageAsync(
        String resourceGroupName, String bastionHostname, List<String> sessionIdsSessionIds, Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (bastionHostname == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter bastionHostname is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        final String apiVersion = "2020-04-01";
        SessionIds sessionIds = new SessionIds();
        sessionIds.setSessionIds(sessionIdsSessionIds);
        return service
            .disconnectActiveSessions(
                this.getHost(),
                resourceGroupName,
                bastionHostname,
                apiVersion,
                this.getSubscriptionId(),
                sessionIds,
                context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().getValue(),
                        res.getValue().getNextLink(),
                        null));
    }

    /**
     * Returns the list of currently active sessions on the Bastion.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param sessionIdsSessionIds List of session IDs.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for DisconnectActiveSessions.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BastionSessionState> disconnectActiveSessionsAsync(
        String resourceGroupName, String bastionHostname, List<String> sessionIdsSessionIds) {
        return new PagedFlux<>(
            () -> disconnectActiveSessionsSinglePageAsync(resourceGroupName, bastionHostname, sessionIdsSessionIds),
            nextLink -> disconnectActiveSessionsNextSinglePageAsync(nextLink));
    }

    /**
     * Returns the list of currently active sessions on the Bastion.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param sessionIdsSessionIds List of session IDs.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for DisconnectActiveSessions.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BastionSessionState> disconnectActiveSessionsAsync(
        String resourceGroupName, String bastionHostname, List<String> sessionIdsSessionIds, Context context) {
        return new PagedFlux<>(
            () ->
                disconnectActiveSessionsSinglePageAsync(
                    resourceGroupName, bastionHostname, sessionIdsSessionIds, context),
            nextLink -> disconnectActiveSessionsNextSinglePageAsync(nextLink));
    }

    /**
     * Returns the list of currently active sessions on the Bastion.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param sessionIdsSessionIds List of session IDs.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for DisconnectActiveSessions.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BastionSessionState> disconnectActiveSessions(
        String resourceGroupName, String bastionHostname, List<String> sessionIdsSessionIds) {
        return new PagedIterable<>(
            disconnectActiveSessionsAsync(resourceGroupName, bastionHostname, sessionIdsSessionIds));
    }

    /**
     * Returns the list of currently active sessions on the Bastion.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param sessionIdsSessionIds List of session IDs.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for DisconnectActiveSessions.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BastionSessionState> disconnectActiveSessions(
        String resourceGroupName, String bastionHostname, List<String> sessionIdsSessionIds, Context context) {
        return new PagedIterable<>(
            disconnectActiveSessionsAsync(resourceGroupName, bastionHostname, sessionIdsSessionIds, context));
    }

    /**
     * Checks whether a domain name in the cloudapp.azure.com zone is available for use.
     *
     * @param location The location of the domain name.
     * @param domainNameLabel The domain name to be verified. It must conform to the following regular expression:
     *     ^[a-z][a-z0-9-]{1,61}[a-z0-9]$.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for the CheckDnsNameAvailability API service call.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DnsNameAvailabilityResult>> checkDnsNameAvailabilityWithResponseAsync(
        String location, String domainNameLabel) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (location == null) {
            return Mono.error(new IllegalArgumentException("Parameter location is required and cannot be null."));
        }
        if (domainNameLabel == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter domainNameLabel is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        final String apiVersion = "2020-04-01";
        return FluxUtil
            .withContext(
                context ->
                    service
                        .checkDnsNameAvailability(
                            this.getHost(), location, domainNameLabel, apiVersion, this.getSubscriptionId(), context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Checks whether a domain name in the cloudapp.azure.com zone is available for use.
     *
     * @param location The location of the domain name.
     * @param domainNameLabel The domain name to be verified. It must conform to the following regular expression:
     *     ^[a-z][a-z0-9-]{1,61}[a-z0-9]$.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for the CheckDnsNameAvailability API service call.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<DnsNameAvailabilityResult>> checkDnsNameAvailabilityWithResponseAsync(
        String location, String domainNameLabel, Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (location == null) {
            return Mono.error(new IllegalArgumentException("Parameter location is required and cannot be null."));
        }
        if (domainNameLabel == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter domainNameLabel is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        final String apiVersion = "2020-04-01";
        return service
            .checkDnsNameAvailability(
                this.getHost(), location, domainNameLabel, apiVersion, this.getSubscriptionId(), context);
    }

    /**
     * Checks whether a domain name in the cloudapp.azure.com zone is available for use.
     *
     * @param location The location of the domain name.
     * @param domainNameLabel The domain name to be verified. It must conform to the following regular expression:
     *     ^[a-z][a-z0-9-]{1,61}[a-z0-9]$.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for the CheckDnsNameAvailability API service call.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DnsNameAvailabilityResult> checkDnsNameAvailabilityAsync(String location, String domainNameLabel) {
        return checkDnsNameAvailabilityWithResponseAsync(location, domainNameLabel)
            .flatMap(
                (Response<DnsNameAvailabilityResult> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Checks whether a domain name in the cloudapp.azure.com zone is available for use.
     *
     * @param location The location of the domain name.
     * @param domainNameLabel The domain name to be verified. It must conform to the following regular expression:
     *     ^[a-z][a-z0-9-]{1,61}[a-z0-9]$.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for the CheckDnsNameAvailability API service call.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DnsNameAvailabilityResult> checkDnsNameAvailabilityAsync(
        String location, String domainNameLabel, Context context) {
        return checkDnsNameAvailabilityWithResponseAsync(location, domainNameLabel, context)
            .flatMap(
                (Response<DnsNameAvailabilityResult> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Checks whether a domain name in the cloudapp.azure.com zone is available for use.
     *
     * @param location The location of the domain name.
     * @param domainNameLabel The domain name to be verified. It must conform to the following regular expression:
     *     ^[a-z][a-z0-9-]{1,61}[a-z0-9]$.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for the CheckDnsNameAvailability API service call.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DnsNameAvailabilityResult checkDnsNameAvailability(String location, String domainNameLabel) {
        return checkDnsNameAvailabilityAsync(location, domainNameLabel).block();
    }

    /**
     * Checks whether a domain name in the cloudapp.azure.com zone is available for use.
     *
     * @param location The location of the domain name.
     * @param domainNameLabel The domain name to be verified. It must conform to the following regular expression:
     *     ^[a-z][a-z0-9-]{1,61}[a-z0-9]$.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for the CheckDnsNameAvailability API service call.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DnsNameAvailabilityResult checkDnsNameAvailability(
        String location, String domainNameLabel, Context context) {
        return checkDnsNameAvailabilityAsync(location, domainNameLabel, context).block();
    }

    /**
     * Gives the supported security providers for the virtual wan.
     *
     * @param resourceGroupName The resource group name.
     * @param virtualWanName The name of the VirtualWAN for which supported security providers are needed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of SecurityProviders.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<VirtualWanSecurityProviders>> supportedSecurityProvidersWithResponseAsync(
        String resourceGroupName, String virtualWanName) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (virtualWanName == null) {
            return Mono.error(new IllegalArgumentException("Parameter virtualWanName is required and cannot be null."));
        }
        final String apiVersion = "2020-04-01";
        return FluxUtil
            .withContext(
                context ->
                    service
                        .supportedSecurityProviders(
                            this.getHost(),
                            this.getSubscriptionId(),
                            resourceGroupName,
                            virtualWanName,
                            apiVersion,
                            context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Gives the supported security providers for the virtual wan.
     *
     * @param resourceGroupName The resource group name.
     * @param virtualWanName The name of the VirtualWAN for which supported security providers are needed.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of SecurityProviders.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<VirtualWanSecurityProviders>> supportedSecurityProvidersWithResponseAsync(
        String resourceGroupName, String virtualWanName, Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (virtualWanName == null) {
            return Mono.error(new IllegalArgumentException("Parameter virtualWanName is required and cannot be null."));
        }
        final String apiVersion = "2020-04-01";
        return service
            .supportedSecurityProviders(
                this.getHost(), this.getSubscriptionId(), resourceGroupName, virtualWanName, apiVersion, context);
    }

    /**
     * Gives the supported security providers for the virtual wan.
     *
     * @param resourceGroupName The resource group name.
     * @param virtualWanName The name of the VirtualWAN for which supported security providers are needed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of SecurityProviders.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<VirtualWanSecurityProviders> supportedSecurityProvidersAsync(
        String resourceGroupName, String virtualWanName) {
        return supportedSecurityProvidersWithResponseAsync(resourceGroupName, virtualWanName)
            .flatMap(
                (Response<VirtualWanSecurityProviders> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Gives the supported security providers for the virtual wan.
     *
     * @param resourceGroupName The resource group name.
     * @param virtualWanName The name of the VirtualWAN for which supported security providers are needed.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of SecurityProviders.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<VirtualWanSecurityProviders> supportedSecurityProvidersAsync(
        String resourceGroupName, String virtualWanName, Context context) {
        return supportedSecurityProvidersWithResponseAsync(resourceGroupName, virtualWanName, context)
            .flatMap(
                (Response<VirtualWanSecurityProviders> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Gives the supported security providers for the virtual wan.
     *
     * @param resourceGroupName The resource group name.
     * @param virtualWanName The name of the VirtualWAN for which supported security providers are needed.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of SecurityProviders.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public VirtualWanSecurityProviders supportedSecurityProviders(String resourceGroupName, String virtualWanName) {
        return supportedSecurityProvidersAsync(resourceGroupName, virtualWanName).block();
    }

    /**
     * Gives the supported security providers for the virtual wan.
     *
     * @param resourceGroupName The resource group name.
     * @param virtualWanName The name of the VirtualWAN for which supported security providers are needed.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return collection of SecurityProviders.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public VirtualWanSecurityProviders supportedSecurityProviders(
        String resourceGroupName, String virtualWanName, Context context) {
        return supportedSecurityProvidersAsync(resourceGroupName, virtualWanName, context).block();
    }

    /**
     * Generates a unique VPN profile for P2S clients for VirtualWan and associated VpnServerConfiguration combination
     * in the specified resource group.
     *
     * @param resourceGroupName The resource group name.
     * @param virtualWanName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param vpnClientParams Virtual Wan Vpn profile parameters Vpn profile generation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return vpn Profile Response for package generation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Flux<ByteBuffer>>> generatevirtualwanvpnserverconfigurationvpnprofileWithResponseAsync(
        String resourceGroupName, String virtualWanName, VirtualWanVpnProfileParameters vpnClientParams) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (virtualWanName == null) {
            return Mono.error(new IllegalArgumentException("Parameter virtualWanName is required and cannot be null."));
        }
        if (vpnClientParams == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter vpnClientParams is required and cannot be null."));
        } else {
            vpnClientParams.validate();
        }
        final String apiVersion = "2020-04-01";
        return FluxUtil
            .withContext(
                context ->
                    service
                        .generatevirtualwanvpnserverconfigurationvpnprofile(
                            this.getHost(),
                            this.getSubscriptionId(),
                            resourceGroupName,
                            virtualWanName,
                            apiVersion,
                            vpnClientParams,
                            context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Generates a unique VPN profile for P2S clients for VirtualWan and associated VpnServerConfiguration combination
     * in the specified resource group.
     *
     * @param resourceGroupName The resource group name.
     * @param virtualWanName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param vpnClientParams Virtual Wan Vpn profile parameters Vpn profile generation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return vpn Profile Response for package generation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Flux<ByteBuffer>>> generatevirtualwanvpnserverconfigurationvpnprofileWithResponseAsync(
        String resourceGroupName,
        String virtualWanName,
        VirtualWanVpnProfileParameters vpnClientParams,
        Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (virtualWanName == null) {
            return Mono.error(new IllegalArgumentException("Parameter virtualWanName is required and cannot be null."));
        }
        if (vpnClientParams == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter vpnClientParams is required and cannot be null."));
        } else {
            vpnClientParams.validate();
        }
        final String apiVersion = "2020-04-01";
        return service
            .generatevirtualwanvpnserverconfigurationvpnprofile(
                this.getHost(),
                this.getSubscriptionId(),
                resourceGroupName,
                virtualWanName,
                apiVersion,
                vpnClientParams,
                context);
    }

    /**
     * Generates a unique VPN profile for P2S clients for VirtualWan and associated VpnServerConfiguration combination
     * in the specified resource group.
     *
     * @param resourceGroupName The resource group name.
     * @param virtualWanName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param vpnClientParams Virtual Wan Vpn profile parameters Vpn profile generation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return vpn Profile Response for package generation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PollerFlux<PollResult<VpnProfileResponse>, VpnProfileResponse>
        beginGeneratevirtualwanvpnserverconfigurationvpnprofile(
            String resourceGroupName, String virtualWanName, VirtualWanVpnProfileParameters vpnClientParams) {
        Mono<Response<Flux<ByteBuffer>>> mono =
            generatevirtualwanvpnserverconfigurationvpnprofileWithResponseAsync(
                resourceGroupName, virtualWanName, vpnClientParams);
        return this
            .<VpnProfileResponse, VpnProfileResponse>getLroResultAsync(
                mono, this.getHttpPipeline(), VpnProfileResponse.class, VpnProfileResponse.class);
    }

    /**
     * Generates a unique VPN profile for P2S clients for VirtualWan and associated VpnServerConfiguration combination
     * in the specified resource group.
     *
     * @param resourceGroupName The resource group name.
     * @param virtualWanName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param vpnClientParams Virtual Wan Vpn profile parameters Vpn profile generation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return vpn Profile Response for package generation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PollerFlux<PollResult<VpnProfileResponse>, VpnProfileResponse>
        beginGeneratevirtualwanvpnserverconfigurationvpnprofile(
            String resourceGroupName,
            String virtualWanName,
            VirtualWanVpnProfileParameters vpnClientParams,
            Context context) {
        Mono<Response<Flux<ByteBuffer>>> mono =
            generatevirtualwanvpnserverconfigurationvpnprofileWithResponseAsync(
                resourceGroupName, virtualWanName, vpnClientParams, context);
        return this
            .<VpnProfileResponse, VpnProfileResponse>getLroResultAsync(
                mono, this.getHttpPipeline(), VpnProfileResponse.class, VpnProfileResponse.class);
    }

    /**
     * Generates a unique VPN profile for P2S clients for VirtualWan and associated VpnServerConfiguration combination
     * in the specified resource group.
     *
     * @param resourceGroupName The resource group name.
     * @param virtualWanName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param vpnClientParams Virtual Wan Vpn profile parameters Vpn profile generation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return vpn Profile Response for package generation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<VpnProfileResponse> generatevirtualwanvpnserverconfigurationvpnprofileAsync(
        String resourceGroupName, String virtualWanName, VirtualWanVpnProfileParameters vpnClientParams) {
        Mono<Response<Flux<ByteBuffer>>> mono =
            generatevirtualwanvpnserverconfigurationvpnprofileWithResponseAsync(
                resourceGroupName, virtualWanName, vpnClientParams);
        return this
            .<VpnProfileResponse, VpnProfileResponse>getLroResultAsync(
                mono, this.getHttpPipeline(), VpnProfileResponse.class, VpnProfileResponse.class)
            .last()
            .flatMap(AsyncPollResponse::getFinalResult);
    }

    /**
     * Generates a unique VPN profile for P2S clients for VirtualWan and associated VpnServerConfiguration combination
     * in the specified resource group.
     *
     * @param resourceGroupName The resource group name.
     * @param virtualWanName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param vpnClientParams Virtual Wan Vpn profile parameters Vpn profile generation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return vpn Profile Response for package generation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<VpnProfileResponse> generatevirtualwanvpnserverconfigurationvpnprofileAsync(
        String resourceGroupName,
        String virtualWanName,
        VirtualWanVpnProfileParameters vpnClientParams,
        Context context) {
        Mono<Response<Flux<ByteBuffer>>> mono =
            generatevirtualwanvpnserverconfigurationvpnprofileWithResponseAsync(
                resourceGroupName, virtualWanName, vpnClientParams, context);
        return this
            .<VpnProfileResponse, VpnProfileResponse>getLroResultAsync(
                mono, this.getHttpPipeline(), VpnProfileResponse.class, VpnProfileResponse.class)
            .last()
            .flatMap(AsyncPollResponse::getFinalResult);
    }

    /**
     * Generates a unique VPN profile for P2S clients for VirtualWan and associated VpnServerConfiguration combination
     * in the specified resource group.
     *
     * @param resourceGroupName The resource group name.
     * @param virtualWanName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param vpnClientParams Virtual Wan Vpn profile parameters Vpn profile generation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return vpn Profile Response for package generation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public VpnProfileResponse generatevirtualwanvpnserverconfigurationvpnprofile(
        String resourceGroupName, String virtualWanName, VirtualWanVpnProfileParameters vpnClientParams) {
        return generatevirtualwanvpnserverconfigurationvpnprofileAsync(
                resourceGroupName, virtualWanName, vpnClientParams)
            .block();
    }

    /**
     * Generates a unique VPN profile for P2S clients for VirtualWan and associated VpnServerConfiguration combination
     * in the specified resource group.
     *
     * @param resourceGroupName The resource group name.
     * @param virtualWanName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param vpnClientParams Virtual Wan Vpn profile parameters Vpn profile generation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return vpn Profile Response for package generation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public VpnProfileResponse generatevirtualwanvpnserverconfigurationvpnprofile(
        String resourceGroupName,
        String virtualWanName,
        VirtualWanVpnProfileParameters vpnClientParams,
        Context context) {
        return generatevirtualwanvpnserverconfigurationvpnprofileAsync(
                resourceGroupName, virtualWanName, vpnClientParams, context)
            .block();
    }

    /**
     * Creates a Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for all the Bastion Shareable Link endpoints.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BastionShareableLinkListResult>> beginPutBastionShareableLinkWithoutPollingWithResponseAsync(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (bastionHostname == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter bastionHostname is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (vms != null) {
            vms.forEach(e -> e.validate());
        }
        final String apiVersion = "2020-04-01";
        BastionShareableLinkListRequest bslRequest = new BastionShareableLinkListRequest();
        bslRequest.setVms(vms);
        return FluxUtil
            .withContext(
                context ->
                    service
                        .beginPutBastionShareableLinkWithoutPolling(
                            this.getHost(),
                            resourceGroupName,
                            bastionHostname,
                            apiVersion,
                            this.getSubscriptionId(),
                            bslRequest,
                            context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Creates a Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for all the Bastion Shareable Link endpoints.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BastionShareableLinkListResult>> beginPutBastionShareableLinkWithoutPollingWithResponseAsync(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms, Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (bastionHostname == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter bastionHostname is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (vms != null) {
            vms.forEach(e -> e.validate());
        }
        final String apiVersion = "2020-04-01";
        BastionShareableLinkListRequest bslRequest = new BastionShareableLinkListRequest();
        bslRequest.setVms(vms);
        return service
            .beginPutBastionShareableLinkWithoutPolling(
                this.getHost(),
                resourceGroupName,
                bastionHostname,
                apiVersion,
                this.getSubscriptionId(),
                bslRequest,
                context);
    }

    /**
     * Creates a Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for all the Bastion Shareable Link endpoints.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BastionShareableLinkListResult> beginPutBastionShareableLinkWithoutPollingAsync(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms) {
        return beginPutBastionShareableLinkWithoutPollingWithResponseAsync(resourceGroupName, bastionHostname, vms)
            .flatMap(
                (Response<BastionShareableLinkListResult> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Creates a Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for all the Bastion Shareable Link endpoints.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BastionShareableLinkListResult> beginPutBastionShareableLinkWithoutPollingAsync(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms, Context context) {
        return beginPutBastionShareableLinkWithoutPollingWithResponseAsync(
                resourceGroupName, bastionHostname, vms, context)
            .flatMap(
                (Response<BastionShareableLinkListResult> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Creates a Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for all the Bastion Shareable Link endpoints.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BastionShareableLinkListResult beginPutBastionShareableLinkWithoutPolling(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms) {
        return beginPutBastionShareableLinkWithoutPollingAsync(resourceGroupName, bastionHostname, vms).block();
    }

    /**
     * Creates a Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for all the Bastion Shareable Link endpoints.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BastionShareableLinkListResult beginPutBastionShareableLinkWithoutPolling(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms, Context context) {
        return beginPutBastionShareableLinkWithoutPollingAsync(resourceGroupName, bastionHostname, vms, context)
            .block();
    }

    /**
     * Deletes the Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> beginDeleteBastionShareableLinkWithoutPollingWithResponseAsync(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (bastionHostname == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter bastionHostname is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (vms != null) {
            vms.forEach(e -> e.validate());
        }
        final String apiVersion = "2020-04-01";
        BastionShareableLinkListRequest bslRequest = new BastionShareableLinkListRequest();
        bslRequest.setVms(vms);
        return FluxUtil
            .withContext(
                context ->
                    service
                        .beginDeleteBastionShareableLinkWithoutPolling(
                            this.getHost(),
                            resourceGroupName,
                            bastionHostname,
                            apiVersion,
                            this.getSubscriptionId(),
                            bslRequest,
                            context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Deletes the Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> beginDeleteBastionShareableLinkWithoutPollingWithResponseAsync(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms, Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (bastionHostname == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter bastionHostname is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (vms != null) {
            vms.forEach(e -> e.validate());
        }
        final String apiVersion = "2020-04-01";
        BastionShareableLinkListRequest bslRequest = new BastionShareableLinkListRequest();
        bslRequest.setVms(vms);
        return service
            .beginDeleteBastionShareableLinkWithoutPolling(
                this.getHost(),
                resourceGroupName,
                bastionHostname,
                apiVersion,
                this.getSubscriptionId(),
                bslRequest,
                context);
    }

    /**
     * Deletes the Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> beginDeleteBastionShareableLinkWithoutPollingAsync(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms) {
        return beginDeleteBastionShareableLinkWithoutPollingWithResponseAsync(resourceGroupName, bastionHostname, vms)
            .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Deletes the Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> beginDeleteBastionShareableLinkWithoutPollingAsync(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms, Context context) {
        return beginDeleteBastionShareableLinkWithoutPollingWithResponseAsync(
                resourceGroupName, bastionHostname, vms, context)
            .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Deletes the Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void beginDeleteBastionShareableLinkWithoutPolling(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms) {
        beginDeleteBastionShareableLinkWithoutPollingAsync(resourceGroupName, bastionHostname, vms).block();
    }

    /**
     * Deletes the Bastion Shareable Links for all the VMs specified in the request.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param vms List of VM references.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void beginDeleteBastionShareableLinkWithoutPolling(
        String resourceGroupName, String bastionHostname, List<BastionShareableLink> vms, Context context) {
        beginDeleteBastionShareableLinkWithoutPollingAsync(resourceGroupName, bastionHostname, vms, context).block();
    }

    /**
     * Returns the list of currently active sessions on the Bastion.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for GetActiveSessions.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BastionActiveSessionListResult>> beginGetActiveSessionsWithoutPollingWithResponseAsync(
        String resourceGroupName, String bastionHostname) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (bastionHostname == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter bastionHostname is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        final String apiVersion = "2020-04-01";
        return FluxUtil
            .withContext(
                context ->
                    service
                        .beginGetActiveSessionsWithoutPolling(
                            this.getHost(),
                            resourceGroupName,
                            bastionHostname,
                            apiVersion,
                            this.getSubscriptionId(),
                            context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Returns the list of currently active sessions on the Bastion.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for GetActiveSessions.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BastionActiveSessionListResult>> beginGetActiveSessionsWithoutPollingWithResponseAsync(
        String resourceGroupName, String bastionHostname, Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (bastionHostname == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter bastionHostname is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        final String apiVersion = "2020-04-01";
        return service
            .beginGetActiveSessionsWithoutPolling(
                this.getHost(), resourceGroupName, bastionHostname, apiVersion, this.getSubscriptionId(), context);
    }

    /**
     * Returns the list of currently active sessions on the Bastion.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for GetActiveSessions.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BastionActiveSessionListResult> beginGetActiveSessionsWithoutPollingAsync(
        String resourceGroupName, String bastionHostname) {
        return beginGetActiveSessionsWithoutPollingWithResponseAsync(resourceGroupName, bastionHostname)
            .flatMap(
                (Response<BastionActiveSessionListResult> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Returns the list of currently active sessions on the Bastion.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for GetActiveSessions.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<BastionActiveSessionListResult> beginGetActiveSessionsWithoutPollingAsync(
        String resourceGroupName, String bastionHostname, Context context) {
        return beginGetActiveSessionsWithoutPollingWithResponseAsync(resourceGroupName, bastionHostname, context)
            .flatMap(
                (Response<BastionActiveSessionListResult> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Returns the list of currently active sessions on the Bastion.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for GetActiveSessions.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BastionActiveSessionListResult beginGetActiveSessionsWithoutPolling(
        String resourceGroupName, String bastionHostname) {
        return beginGetActiveSessionsWithoutPollingAsync(resourceGroupName, bastionHostname).block();
    }

    /**
     * Returns the list of currently active sessions on the Bastion.
     *
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostname The name of the Bastion Host.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for GetActiveSessions.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public BastionActiveSessionListResult beginGetActiveSessionsWithoutPolling(
        String resourceGroupName, String bastionHostname, Context context) {
        return beginGetActiveSessionsWithoutPollingAsync(resourceGroupName, bastionHostname, context).block();
    }

    /**
     * Generates a unique VPN profile for P2S clients for VirtualWan and associated VpnServerConfiguration combination
     * in the specified resource group.
     *
     * @param resourceGroupName The resource group name.
     * @param virtualWanName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param vpnClientParams Virtual Wan Vpn profile parameters Vpn profile generation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return vpn Profile Response for package generation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<VpnProfileResponse>>
        beginGeneratevirtualwanvpnserverconfigurationvpnprofileWithoutPollingWithResponseAsync(
            String resourceGroupName, String virtualWanName, VirtualWanVpnProfileParameters vpnClientParams) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (virtualWanName == null) {
            return Mono.error(new IllegalArgumentException("Parameter virtualWanName is required and cannot be null."));
        }
        if (vpnClientParams == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter vpnClientParams is required and cannot be null."));
        } else {
            vpnClientParams.validate();
        }
        final String apiVersion = "2020-04-01";
        return FluxUtil
            .withContext(
                context ->
                    service
                        .beginGeneratevirtualwanvpnserverconfigurationvpnprofileWithoutPolling(
                            this.getHost(),
                            this.getSubscriptionId(),
                            resourceGroupName,
                            virtualWanName,
                            apiVersion,
                            vpnClientParams,
                            context))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Generates a unique VPN profile for P2S clients for VirtualWan and associated VpnServerConfiguration combination
     * in the specified resource group.
     *
     * @param resourceGroupName The resource group name.
     * @param virtualWanName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param vpnClientParams Virtual Wan Vpn profile parameters Vpn profile generation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return vpn Profile Response for package generation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<VpnProfileResponse>>
        beginGeneratevirtualwanvpnserverconfigurationvpnprofileWithoutPollingWithResponseAsync(
            String resourceGroupName,
            String virtualWanName,
            VirtualWanVpnProfileParameters vpnClientParams,
            Context context) {
        if (this.getHost() == null) {
            return Mono.error(new IllegalArgumentException("Parameter this.getHost() is required and cannot be null."));
        }
        if (this.getSubscriptionId() == null) {
            return Mono
                .error(
                    new IllegalArgumentException("Parameter this.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (virtualWanName == null) {
            return Mono.error(new IllegalArgumentException("Parameter virtualWanName is required and cannot be null."));
        }
        if (vpnClientParams == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter vpnClientParams is required and cannot be null."));
        } else {
            vpnClientParams.validate();
        }
        final String apiVersion = "2020-04-01";
        return service
            .beginGeneratevirtualwanvpnserverconfigurationvpnprofileWithoutPolling(
                this.getHost(),
                this.getSubscriptionId(),
                resourceGroupName,
                virtualWanName,
                apiVersion,
                vpnClientParams,
                context);
    }

    /**
     * Generates a unique VPN profile for P2S clients for VirtualWan and associated VpnServerConfiguration combination
     * in the specified resource group.
     *
     * @param resourceGroupName The resource group name.
     * @param virtualWanName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param vpnClientParams Virtual Wan Vpn profile parameters Vpn profile generation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return vpn Profile Response for package generation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<VpnProfileResponse> beginGeneratevirtualwanvpnserverconfigurationvpnprofileWithoutPollingAsync(
        String resourceGroupName, String virtualWanName, VirtualWanVpnProfileParameters vpnClientParams) {
        return beginGeneratevirtualwanvpnserverconfigurationvpnprofileWithoutPollingWithResponseAsync(
                resourceGroupName, virtualWanName, vpnClientParams)
            .flatMap(
                (Response<VpnProfileResponse> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Generates a unique VPN profile for P2S clients for VirtualWan and associated VpnServerConfiguration combination
     * in the specified resource group.
     *
     * @param resourceGroupName The resource group name.
     * @param virtualWanName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param vpnClientParams Virtual Wan Vpn profile parameters Vpn profile generation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return vpn Profile Response for package generation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<VpnProfileResponse> beginGeneratevirtualwanvpnserverconfigurationvpnprofileWithoutPollingAsync(
        String resourceGroupName,
        String virtualWanName,
        VirtualWanVpnProfileParameters vpnClientParams,
        Context context) {
        return beginGeneratevirtualwanvpnserverconfigurationvpnprofileWithoutPollingWithResponseAsync(
                resourceGroupName, virtualWanName, vpnClientParams, context)
            .flatMap(
                (Response<VpnProfileResponse> res) -> {
                    if (res.getValue() != null) {
                        return Mono.just(res.getValue());
                    } else {
                        return Mono.empty();
                    }
                });
    }

    /**
     * Generates a unique VPN profile for P2S clients for VirtualWan and associated VpnServerConfiguration combination
     * in the specified resource group.
     *
     * @param resourceGroupName The resource group name.
     * @param virtualWanName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param vpnClientParams Virtual Wan Vpn profile parameters Vpn profile generation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return vpn Profile Response for package generation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public VpnProfileResponse beginGeneratevirtualwanvpnserverconfigurationvpnprofileWithoutPolling(
        String resourceGroupName, String virtualWanName, VirtualWanVpnProfileParameters vpnClientParams) {
        return beginGeneratevirtualwanvpnserverconfigurationvpnprofileWithoutPollingAsync(
                resourceGroupName, virtualWanName, vpnClientParams)
            .block();
    }

    /**
     * Generates a unique VPN profile for P2S clients for VirtualWan and associated VpnServerConfiguration combination
     * in the specified resource group.
     *
     * @param resourceGroupName The resource group name.
     * @param virtualWanName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param vpnClientParams Virtual Wan Vpn profile parameters Vpn profile generation.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return vpn Profile Response for package generation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public VpnProfileResponse beginGeneratevirtualwanvpnserverconfigurationvpnprofileWithoutPolling(
        String resourceGroupName,
        String virtualWanName,
        VirtualWanVpnProfileParameters vpnClientParams,
        Context context) {
        return beginGeneratevirtualwanvpnserverconfigurationvpnprofileWithoutPollingAsync(
                resourceGroupName, virtualWanName, vpnClientParams, context)
            .block();
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for all the Bastion Shareable Link endpoints.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BastionShareableLink>> getBastionShareableLinkNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.getBastionShareableLinkNext(nextLink, context))
            .<PagedResponse<BastionShareableLink>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().getValue(),
                        res.getValue().getNextLink(),
                        null))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for all the Bastion Shareable Link endpoints.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BastionShareableLink>> getBastionShareableLinkNextSinglePageAsync(
        String nextLink, Context context) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        return service
            .getBastionShareableLinkNext(nextLink, context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().getValue(),
                        res.getValue().getNextLink(),
                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for DisconnectActiveSessions.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BastionSessionState>> disconnectActiveSessionsNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.disconnectActiveSessionsNext(nextLink, context))
            .<PagedResponse<BastionSessionState>>map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().getValue(),
                        res.getValue().getNextLink(),
                        null))
            .subscriberContext(context -> context.putAll(FluxUtil.toReactorContext(this.getContext())));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response for DisconnectActiveSessions.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BastionSessionState>> disconnectActiveSessionsNextSinglePageAsync(
        String nextLink, Context context) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        return service
            .disconnectActiveSessionsNext(nextLink, context)
            .map(
                res ->
                    new PagedResponseBase<>(
                        res.getRequest(),
                        res.getStatusCode(),
                        res.getHeaders(),
                        res.getValue().getValue(),
                        res.getValue().getNextLink(),
                        null));
    }
}
